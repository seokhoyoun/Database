-- DAY10 DDL

-- 데이터무결성 제약조건 CONSTRAINTS

-- 1. NOT NULL 사용
-- 컬럼에 값이 반드시 기록되어야할때 사용한다.
-- EX) 웹에서 필수입력항목 
-- 컬럼 레벨에서만 설정할 수 있음
CREATE TABLE TESTNN (
NNID NUMBER(5) NOT NULL, -- 컬럼레벨
NN_NAME VARCHAR2(20)

);
-- 기록테스트
INSERT INTO TESTNN (NNID,NN_NAME)
VALUES (NULL,NULL
);
-- ERROR : NNID에 NOT NULL 제약조건에 위배
INSERT INTO TESTNN -- 컬럼명 생략되면, 테이블의 모든값을 VALUES절에 기록해야함
VALUES(1,NULL); -- 테이블의 컬럼 생성 순서와 자료형 맞춰서 값 기록 나열함.

SELECT * FROM TESTNN;

INSERT INTO TESTNN (NN_NAME)
VALUES ("ORACLE"); -- ERROR! 생략된 컬럼은 자동 NULL처리가 되는데 NNID 컬럼은 NOT NULL이 설정되어있음.

-- 테이블 레벨 적용
CREATE TABLE TESTNN2 (
	NN_ID NUMBER(5) CONSTRAINT T2_NNID NOT NULL,
	NN_NAME VARCHAR2(10)
	--  테이블레벨
	--[ CONSTRAINT / 제약조건 이름] / 제약조건 종류 (적용할 컬럼명)
--	CONSTRAINT T2_NN_NAME NOT NULL (NN_NAME) ERROR! 테이블레벨에서는 사용 불가능
);

-- 2. UNIQUE
-- 해당 컬럼의 중복값(같은값) 입력을 막겠다는 의미의 제약조건
-- 설정하면 같은 값은 두번 기록 못 하는 컬럼이 된다.
-- 컬럼레벨, 테이블레벨 둘 다 설정가능하다.
-- 복합키로도 설정할 수 있음

CREATE TABLE TESTUN(
UN_ID CHAR(3) UNIQUE,
UN_NAME VARCHAR2(10) NOT NULL 
);

-- 기록테스트
INSERT INTO TESTUN VALUES ('AAA', 'ORACLE');
SELECT * FROM TESTUN;
INSERT INTO TESTUN VALUES ('AAA', 'JAVA'); -- ERROR! UNIQUE 제약조건에 위배
INSERT INTO TESTUN VALUES ('NNN', 'JAVA');

CREATE TABLE TSETUN2 (
UN_ID CHAR(3) CONSTRAINT T2_UN_ID UNIQUE,
UN_NAME VARCHAR2(10) CONSTRAINT T2_UN_NAME NOT NULL
);

CREATE TABLE TESTUN3 (
UN_ID CHAR(3),
UN_NAME VARCHAR2(10) NOT NULL,
CONSTRAINT T3_UNID UNIQUE (UN_ID)
);

-- 3. PRIMARY KEY
-- 테이블에서 한 행의 정보를 찾기위해 쓸수있는 값이 기록된 칼럼에 적용함
-- NOT NULL + UNIQUE
-- 한 테이블에 한번만 사용 가능하다.

CREATE TABLE TESTPK(
	PK_ID NUMBER PRIMARY KEY,
	PK_NAME VARCHAR2(15) NOT NULL,
	PK_DATE DATE
);
-- 기록테스트
INSERT INTO TESTPK VALUES(1,'홍길동', '15/03/12');
INSERT INTO TESTPK VALUES(NULL, '박문수', SYSDATE); -- ERROR! 기본키에는 NULL 불가능
INSERT INTO TESTPK VALUES (1,'박문수',SYSDATE); -- ERRO! UNIQUE문제!
INSERT INTO TESTPK VALUES (2,'박문수',SYSDATE); 

SELECT * FROM TESTPK;

-- 테이블당 한번만 설정할 수 있음
CREATE TABLE TESTPK2 (
PID NUMBER PRIMARY KEY,
PNAME VARCHAR2(15) PRIMARY KEY --ERROR 2번사용
);

-- 컬럼레벨에서 설정
CREATE TABLE TESTPK2 (
PID NUMBER CONSTRAINT P2_PID PRIMARY KEY,
PNAME VARCHAR2(15) ,
PDATE DATE
);

-- 테이블레벨에서 설정
CREATE TABLE TESTPK3(
PID NUMBER,
PNAME VARCHAR2(15),
PDATE DATE,
CONSTRAINT P3_PID PRIMARY KEY(PID)
);

-- 4. CHECK
-- 컬럼에 기록되는 값에 대한 조건 설정을 한는 제약조건임
-- CHECK (컬럼명 연산자 비교값)
-- 비교값은 고정값이어야함. 바뀌는 값이면 에러.

CREATE TABLE TESTCHK (
C_NAME VARCHAR2(15) CONSTRAINT TCK_NAME NOT NULL,
C_PRICE NUMBER(5) CHECK(C_PRICE BETWEEN 1 AND 99999),
C_LEVEL CHAR(1) CHECK(C_LEVEL IN ('A','B','C'))
);

INSERT INTO TESTCHK VALUES ('GALAXY S9', 65000, 'A');
INSERT INTO TESTCHK VALUES ('LG G7',650000, 'A'); -- ERROR! CHECK 제약조건에 위배
INSERT INTO TESTCHK VALUES ('LG G7', 65000, 'G'); -- ERROR!  ``
INSERT INTO TESTCHK VALUES ('LG G7' , 65000, 'A');


SELECT * FROM TESTCHK;

CREATE TABLE CONSTRAINT_EMP(
EID	CHAR(3) CONSTRAINT PK_EID PRIMARY KEY,
ENAME VARCHAR2(20) CONSTRAINT NENAME NOT NULL,
ENO	CHAR(14) CONSTRAINT NENO NOT NULL CONSTRAINT UENO UNIQUE,
EMAIL	VARCHAR2(25) CONSTRAINT UEMAIL UNIQUE,
PHONE VARCHAR2(12),
HIRE_DATE DATE DEFAULT SYSDATE,
JID	CHAR(2) CONSTRAINT FK_JID REFERENCES JOB ON DELETE SET NULL,
SALARY	NUMBER,
BONUS_PCT	NUMBER,
MARRIAGE	CHAR(1) DEFAULT 'N' CONSTRAINT CHK CHECK (MARRIAGE IN ('Y','N')),
MID	CHAR(3) CONSTRAINT FK_MID REFERENCES CONSTRAINT_EMP ON DELETE SET NULL,
DID	CHAR(2),
CONSTRAINT	FK_DID FOREIGN KEY(DID) REFERENCES DEPARTMENT ON DELETE CASCADE
);

CREATE TABLE TESTCHK2 (
C_NAME VARCHAR2(15) PRIMARY KEY,
C_PRICE NUMBER(5) 	CHECK(C_PRICE >= 1 AND C_PRICE <= 99999),
C_LEVEL CHAR(1) 		CHECK(C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
--C_DATE DATE		CHECK(C_DATE < SYSDATE)
-- 비교값은 반드시 리터럴(값) 사용, 바뀌는 값은 사용 못한다.
C_DATE 	DATE		CHECK(C_DATE < '18/MAY/01')
);

--5 FOREIGN KEY
-- 외래키 외부키
-- 다른 테이블에서 제공하는 값만 사용할 수 있는 컬럼을 의미한다
-- 제공되지 않는 값 사용하면 에러남
--컬럼레벨에서 설정
-- [CONSTRANT 이름] REFERENCES 참조테이블명 [(참조할 컬럼명)]
--테이블레벨에서 설정
-- [CONSTRANT 이름] FOREIGN KEY (적용할 컬럼명) REFERENCES 참조테이블 [(참조컬럼명)]
-- NULL 사용할수있다.

CREATE TABLE TESTFK(
EMP_ID CHAR(3) REFERENCES EMPLOYEE,
-- 참조컬럼명이 생략되면 PRIMARY KEY 컬럼이 자동 연결된다.
DEPT_ID CHAR(2) CONSTRAINT TFK_DID REFERENCES DEPARTMENT (DEPT_ID),
JOB_ID CHAR(2),
CONSTRAINT TFK_JID FOREIGN KEY (JOB_ID) REFERENCES JOB (JOB_ID)
);

-- 기록테스트
-- 연결된 테이블의 연결된 컬럼에 기록되어있는 값만 사용할 수 있음.
INSERT INTO TESTFK VALUES ('300',NULL,NULL); --ERROR 부모키에 300 사번이없다
INSERT INTO TESTFK VALUES ('100',NULL,NULL);
INSERT INTO TESTFK VALUES ('200','70',NULL); --ERROR 70번이 없다
INSERT INTO TESTFK VALUES ('200','90',NULL);
INSERT INTO TESTFK VALUES ('124','90','J9'); -- ERROR J9없음
INSERT INTO TESTFK VALUES ('124','90','J5');
SELECT * FROM TESTFK;

-- 외래키 제약조건에서 PARENT KEY가 될수 있는 컬럼은
-- PRIMARY KEY 또는 UNIQUE 제약조건이 설정된 컬럼만 참조 컬럼이 될 수 있다.
CREATE TABLE NOPK (
ID CHAR(3),
NAME VARCHAR2(10)
);

CREATE TABLE TESTFK2(
F_ID CHAR(3) REFERENCES NOPK(ID), -- ERROR!! PRIMARY KEY 도 UNIQUE 아님
FNAME VARCHAR2(10)
);

CREATE TABLE TESTUN5(
ID CHAR(3) UNIQUE,
NAME VARCHAR2(10)
);

CREATE TABLE TESTFK2(
F_ID CHAR(3) REFERENCES TESTUN5(ID), -- ERROR!! PRIMARY KEY 도 UNIQUE 아님
FNAME VARCHAR2(10)
);

-- 복합키 설정 관련
-- 여러개의 컬럼을 묶어서 UNIQUE 제약조건이나 PRIMARY KEY 제약조건을
-- 설정한 복합키를 참조할 경우
CREATE TABLE TEST_COMPLEX(
ID NUMBER,
NAME VARCHAR2(10),
UNIQUE (ID,NAME)
);

INSERT INTO TEST_COMPLEX VALUES (100,'ORACLE');
INSERT INTO TEST_COMPLEX VALUES (NULL,NULL);
INSERT INTO TEST_COMPLEX VALUES (100,'JAVA');
INSERT INTO TEST_COMPLEX VALUES (NULL,NULL);
INSERT INTO TEST_COMPLEX VALUES (NULL,'JAVA');
INSERT INTO TEST_COMPLEX VALUES (NULL,'JAVA'); -- ERROR! 

SELECT * FROM TEST_COMPLEX;

-- 복합키를 참조키로 설정할 경우
CREATE TABLE TESTFK4 (
ID NUMBER REFERENCES TEST_COMPLEX (ID),
NAME VARCHAR2(10) REFERENCES TEST_COMPLEX (NAME),
PRICE NUMBER
--FOREIGN KEY (ID) REFERENCES TEST_COMPLEX (ID_NAME)
);
-- 외래키가 설정된 값이 사용중이면, 부모키는 절대 삭제할 수 없음
DELETE FROM DEPARTMENT
WHERE DEPT_ID = '90'; --ERROR 삭제못함 
-- EMPLOYEE 테이블에 DEPT_ID 컬럼에 90이 사용되고 있음 CHILD RECORD
-- FOREIGN KEY 제약조건 설정시 삭제옵션 추가할 수 있음: DELETION OPTION
-- 기본은  자식 레코드가 존재하면 부모 키는 삭제 불가능이 기본 RESTRICTED
-- ON DELETE SET NULL, ON DELETE CASCADE

-- ON DELETE SET NULL 추가
-- 부모키가 삭제될 때 자식 레코드 값을 NULL로 바꿈
CREATE TABLE PRODUCT_STATE(
PSTATE CHAR(1) PRIMARY KEY,
PCOMMENT VARCHAR2(10)
);

INSERT INTO PRODUCT_STATE VALUES('A','최고급');
INSERT INTO PRODUCT_STATE VALUES('B','보통');
INSERT INTO PRODUCT_STATE VALUES('C','저급');

SELECT * FROM PRODUCT_STATE;

CREATE TABLE PRODUCT(
PNAME VARCHAR2(20) PRIMARY KEY,
PRICE NUMBER CHECK(PRICE > 0),
PSTATE CHAR(1) REFERENCES PRODUCT_STATE ON DELETE SET NULL
);

INSERT INTO PRODUCT VALUES ('갤럭시',650000,'A');
INSERT INTO PRODUCT VALUES ('G7',750000,'B');
INSERT INTO PRODUCT VALUES ('맥북',2550000,'C');

SELECT * FROM PRODUCT;
--삭제 테스트

DELETE FROM PRODUCT_STATE
WHERE PSTATE = 'A';

COMMIT;

SELECT * FROM PRODUCT;
SELECT * FROM PRODUCT_STATE;

-- ON DELETE CASCADE
-- 제공되는 부모키가 삭제되면, 제공값을 사용하는 자식 레코드도 함께 삭제된다.

CREATE TABLE PRODUCT2(
PNAME VARCHAR2(20) PRIMARY KEY,
PRICE NUMBER,
PSTATE CHAR(1) REFERENCES PRODUCT_STATE(PSTATE) ON DELETE CASCADE
);

INSERT INTO PRODUCT2 VALUES ('맥북',2500000,'B');
INSERT INTO PRODUCT2 VALUES ('G7',750000,'C');

SELECT * FROM PRODUCT2;

-- 삭제테스트
DELETE FROM PRODUCT_STATE
WHERE PSTATE = 'B';
COMMIT;
SELECT * FROM PRODUCT_STATE;

CREATE TABLE TABLE_SUBQUERY1
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID);

SELECT * FROM TABLE_SUBQUERY1;

--DESCRIBE 테이블명;
-- DESC 테이블명;
-- 테이블의 구조를 확인하는 명령어
DESC TABLE_SUBQUERY1;

-- 직원 테이블에서 90번 부서에 소속된 직원 정보만 따로 EMP_COPY90테이블에 저장
CREATE TABLE EMP_COPY90
AS
SELECT * FROM EMPLOYEE
WHERE DEPT_ID ='90';

SELECT * FROM EMP_COPY90;

DESC EMP_COPY90;

-- 복사본 테이블만들기
CREATE TABLE EMP_COPY
AS SELECT * FROM EMPLOYEE;

-- 서브쿼리를 이용해서 기존 테이블을 복사할 경우
-- 컬럼명, 자료형 , NOT NULL 제약조건 값은 그대로 복사
-- 하지만, 나머지 제약조건은 복사되지않는다.

-- 제약조건 관련 데이터딕셔너리 확인
-- USER_CONSTRAINTS
SELECT * FROM USER_CONSTRAINTS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_COPY';

--실습
-- 사번 이름 급여 직급명 부서명 근무지역명 소속국가명 조회
-- 조회 결과를 EMP_LIST 테이블에 저장함

SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
LEFT JOIN	 JOB USING (JOB_ID)
LEFT JOIN	DEPARTMENT D USING (DEPT_ID)
LEFT JOIN	LOCATION L ON (D.LOC_ID = L.LOCATION_ID)
LEFT JOIN	COUNTRY USING (COUNTRY_ID);

CREATE TABLE EMP_LIST
AS
SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
LEFT JOIN	 JOB USING (JOB_ID)
LEFT JOIN	DEPARTMENT D USING (DEPT_ID)
LEFT JOIN	LOCATION L ON (D.LOC_ID = L.LOCATION_ID)
LEFT JOIN	COUNTRY USING (COUNTRY_ID);

--실습2
-- EMPLOYEE 테이블에서 남자 직원의 정보만 조회해서 EMP_MAN 테이블저장
SELECT *
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1) IN (1,3);

CREATE TABLE EMP_MAN
AS
SELECT *
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1) IN (1,3);

--실습3
-- 여자직원 정보만 조회 EMP_FEMALE 테이블에 저장

CREATE TABLE EMP_FEMALE
AS
SELECT *
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1) IN (2,4);

--실습4
-- 부서별 직원 명단을 정리해서 PART_LIST 테이블에 저장함
-- DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID로 컬럼 구성
CREATE TABLE PART_LIST
AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID);
-- ORDER BY DEPT_NAME


COMMENT ON COLUMN PART_LIST.DEPT_NAME IS '부서명';
COMMENT ON COLUMN PART_LIST.JOB_TITLE IS '직급명';
COMMENT ON COLUMN PART_LIST.EMP_NAME IS '사원명';
COMMENT ON COLUMN PART_LIST.EMP_ID IS '사번';

-- 실습 : 제약조건이 설정된 테이블 만들기
-- 테이블명 : PHONEBOOK
-- 컬럼명 :  ID  CHAR(3) 기본키(저장이름 : PK_PBID)
--         PNAME      VARCHAR2(20)  널 사용못함.
--                                 (NN_PBNAME) 
--         PHONE      VARCHAR2(15)  널 사용못함
--                                 (NN_PBPHONE)
--                                 중복값 입력못함
--                                 (UN_PBPHONE)
--         ADDRESS    VARCHAR2(100) 기본값 지정함
--                                 '서울시 구로구'

-- NOT NULL을 제외하고, 모두 테이블 레벨에서 지정함.

CREATE TABLE PHONEBOOK(
ID	CHAR(3) CONSTRAINTS PK_PBID PRIMARY KEY,
PNAME VARCHAR2(20) CONSTRAINTS NN_PBNAME NOT NULL,
PHONE VARCHAR2(15) CONSTRAINTS NNPBPHONE NOT NULL CONSTRAINTS UN_PBPHONE UNIQUE,
ADDRESS VARCHAR2(100) DEFAULT '서울시 구로구'
);

CREATE TABLE PHONEBOOK2(
ID	CHAR(3),
PNAME VARCHAR2(20) CONSTRAINTS NN_PBNAME2 NOT NULL,
PHONE VARCHAR2(15) CONSTRAINTS NN_PBPHONE2 NOT NULL,
ADDRESS VARCHAR2(100) DEFAULT '서울시 구로구',
CONSTRAINTS PK_PBID2 PRIMARY KEY (ID),
CONSTRAINTS UN_PBPHONE2 UNIQUE(PHONE)
);

INSERT INTO PHONEBOOK2 VALUES ('A01','홍길동','010-123-4233',DEFAULT);

SELECT * FROM PHONEBOOK2;

SELECT *
FROM USER_CONSTRAINTS;
-- 데이터 딕셔너리 (데이터 사전)
-- 사용자가 생성한 모든 객체정보는 테이블 단위로 저장되고 있음
-- 예를들면, 사용자가 설정한 제약조건도 저장되고있음.
-- USER_CONSTRAINTS
DESC USER_CONSTRAINTS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'PHONEBOOK';

-- CONSTRAINTS TYPE
--P : PRIMARY KEY
--U : UNIQUE
--R : FOREIGN KEY (REFERENCES)
--C : CHECK , NOT NULL

-- 서브쿼리를 사용해서 테이블을 만들 때, 데이터는 복사하지 않고
-- 테이블 구조만 복사하고 싶은 경우
-- 서브쿼리의 WHERE절에 1 = 0 하면 된다
CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPARTMENT
WHERE 1=0;

SELECT * FROM DEPT_COPY;
DESC DEPT_COPY;
-- 서브쿼리로 새 테이블을 만들 때, 서브쿼리의 컬럼명을 사용하지않고
-- 새 테이블에서 컬럼명을 다르게 구성할 수 있다.

-- 첫번째 방법
CREATE TABLE JOB_COPY (직급코드, 직급명, 최저급여, 최고급여)
AS
SELECT * FROM JOB;

DESC JOB_COPY;

-- 두번째 방법
CREATE TABLE DCOPY
AS
SELECT DEPT_ID AS DID, DEPT_NAME AS DNAME, LOC_ID LID
FROM DEPARTMENT;
DESC DCOPY;

-- 서브쿼리로 테이블을 만들 때, 컬럼명을 바꾸면서 제약조건도 추가할 수 있음
-- 외래키 설정(FOREIGN KEY) 제약조건은 추가할 수 없음
CREATE TABLE TSUB3 (
EID PRIMARY KEY,
ENAME,
SAL CHECK SAL > 2000000, -- 급여에 2000000보다 작은값이 존재함
DID, --REFERENCES DEPARTMENT, ERROR!!
JTITLE )--NOT NULL) -- ERROR 서브쿼리결과에 NULL이 이미 있다
AS
SELECT EMP_ID, EMP_NAME, SALARY, DEPT_ID, JOB_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID);

-- 해결
CREATE TABLE TSUB3 (
EID PRIMARY KEY,
ENAME,
SAL CHECK (SAL > 2000000), -- 급여에 2000000보다 작은값이 존재함
DID, --REFERENCES DEPARTMENT, ERROR!!
JTITLE NOT NULL) -- ERROR 서브쿼리결과에 NULL이 이미 있다
AS
SELECT EMP_ID, EMP_NAME, SALARY, DEPT_ID, NVL(JOB_TITLE,'미정')
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID)
WHERE SALARY > 2000000;










